#include <cassert>
#include <expected>
#include <optional>
#include <sstream>
#include <string>
#include <vector>
#include <print>
#include <fstream>

using std::println;
using std::vector;
using std::string;

enum InstrType {
    INS_ADD,
    INS_MUL,
    INS_INPUT,
    INS_OUTPUT,
    INS_HALT
};

long size_from_type(InstrType typ) {
    switch (typ) {
        case INS_ADD:
        case INS_MUL:
            return 4;
        case INS_INPUT:
        case INS_OUTPUT:
            return 2;
        case INS_HALT:
            return 1;
    }
}

enum Mode {
    MODE_IM,
    MODE_POS,
};

struct Instruction {
    InstrType type;
    long opcode;
    vector<long> params;
    vector<Mode> modes;
    long size;
};

class Machine {
    vector<long> memory;
    vector<long> input;
    vector<long> output;
    long ip;
public:
    void load_mem_from_string(string string);
    std::optional<Instruction> make_instruction() const;
    void run();
};

void Machine::load_mem_from_string(string string) {
    std::stringstream ss(string);
    for (long i; ss >> i;) {
        memory.push_back(i);
        if (ss.peek() == ',') ss.ignore();
    }

}

std::optional<Instruction> Machine::make_instruction() const {
    long instrcode = memory[ip];
    long opcode = instrcode % 100;
    instrcode /= 100;

    Instruction instr;
    if (opcode == 1) {
        instr.type = INS_ADD;
    } else if (opcode == 2) {
        instr.type = INS_MUL;
    } else if (opcode == 99) {
        instr.type = INS_HALT;
    } else {
        return std::nullopt;
    }

    instr.size = size_from_type(instr.type);
    for (int i=1; i<instr.size; i++) {
        instr.params.push_back(memory[ip+i]);
        if (instrcode % 10 == 0) instr.modes.push_back(MODE_POS);
        else if (instrcode % 10 == 1) instr.modes.push_back(MODE_IM);
        else {
            println("ERROR: Unknown mode: {}", instrcode % 10);
            return std::nullopt;
        }
    }

    return instr;
}

std::expected<vector<string>, string> read_file(const string &filename);

int main(void) {
    string filename = "data/input.txt";
    auto result = read_file(filename);
    if (!result) {
        println("ERROR: Filename = '{}'", filename);
        return 1;
    }
    vector<string> file_contents = result.value();
    assert(file_contents.size() == 1);

    Machine machine;
    machine.load_mem_from_string(file_contents[0]);

    long part1 = 0;
    long part2 = 0;

    println("Part 1: {}", part1);
    println("Part 2: {}", part2);

    return 0;
}

bool interpret_memory(vector<long>& memory) {
    long i_count = memory.size();

    for (long ip=0; ip<i_count; ) {

        auto instr = make_instruction(ip, memory);
        if (!instr) return false;
        if (instr->opcode == 1) {
            memory[instr->params[2]] = memory[instr->params[0]] + memory[instr->params[1]];
        } else if (instr->opcode == 2) {
            memory[instr->params[2]] = memory[instr->params[0]] * memory[instr->params[1]];
        } else if (instr->opcode == 99) {
            instr = HALT;
            break;
        } else {
            return false;
        }
        ip += instr->size;
    }
    return true;
}

std::expected<vector<string>, string> read_file(const string &filename) {
    std::ifstream file_stream(filename);
    if (!file_stream.is_open())
        return std::unexpected("Failed to open file: " + filename);

    vector<string> file_contents;
    string line;
    while (std::getline(file_stream, line)) file_contents.push_back(std::move(line));
    return file_contents;
}

